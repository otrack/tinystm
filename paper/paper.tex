\documentclass[]{llncs}
\usepackage{times}
\usepackage{format}
\usepackage{macros}
\usepackage{macros_stm}
\usepackage{paper}
\usepackage{url}
\usepackage[colorlinks=true,linkcolor=blue,urlcolor=blue,citecolor=blue]{hyperref}
\begin{document}

\newboolean{showcomments}
\setboolean{showcomments}{false}
\ifthenelse{\boolean{showcomments}}
{ \newcommand{\mynote}[3]{
   \fbox{\bfseries\sffamily\scriptsize#1}
   {\small$\blacktriangleright$\textsf{\emph{\color{#3}{#2}}}$\blacktriangleleft$}}}
{ \newcommand{\mynote}[3]{}}
% One command per author:
\newcommand{\pf}[1]{\mynote{Pierre}{#1}{red}}
\newcommand{\hm}[1]{\mynote{Patrick}{#1}{pink}}
\newcommand{\vs}[1]{\mynote{Valerio}{#1}{blue}}
\newcommand{\ft}[1]{\mynote{Francois}{#1}{green}}

% tentative results 
% https://docs.google.com/spreadsheets/d/1jqpC7ehu48kJc96EYcEFRbjgV9wq8E9HbdZpwREfw7w/edit#gid=1043149494
% slides from euro-tm 2014
% https://docs.google.com/presentation/d/1AFntDVRBWmjOMjNzX90ZGo0cG4Jd7Pewas4CeemD5TQ/edit#slide=id.p

\title{Boosting Transactional Memory\\with Stricter Serializability%
  \thanks{
    This research is partly supported by the RainbowFS project of Agence Nationale de la Recherche, France, number ANR-16-CE25-0013-01a.
  }
}
%\titlerunning{} %only if title too long

\author{
  Pierre Sutra\inst{2}
  \and Patrick Marlier\inst{1}
  \and Valerio Schiavoni\inst{1} % \orcidID{0000-0003-1493-6603}
  \and Fran\c{c}ois Trahay\inst{2} % \orcidID{0000-0001-7329-1812}
}

\institute{
  University of Neuch\^atel, Switzerland
  % \email{\{patrick.marlier,valerio.schiavoni\}@unine.ch}
  \and
  T\'el\'ecom SudParis, France
  % \email{\{pierre.sutra,francois.trahay\}@telecom-sudparis.eu}
}


\maketitle

\noindent
\makebox[\linewidth]{\small Updated on August 2018}

\begin{abstract}
  Transactional memory (TM) guarantees that a sequence of operations encapsulated into a transaction is atomic.
  This simple yet powerful paradigm is a promising direction for writing concurrent applications.
  %
  Recent TM designs employ a time-based mechanism to leverage the performance advantage of invisible reads.
  With the advent of many-core architectures and non-uniform memory (NUMA) architectures, this technique is however hitting the synchronization wall of the cache coherency protocol.
  %
  To address this limitation, we propose a novel and flexible approach based on a new consistency criterion named stricter serializability ($\SPSER$).
  Workloads executed under $\SPSER$ are opaque when the object graph forms a tree and transactions traverse it top-down.  
  We present a matching algorithm that supports invisible reads, lazy snapshots, and that can trade synchronization for more parallelism.
  Several empirical results against a well-established TM design demonstrate the benefits of our solution.
  \keywords{Transactional memory \and NUMA \and stricter serializability}
\end{abstract}

\input{introduction}
\input{criterion}
\input{stm}
%\input{extensions}
\input{evaluation}
\input{relatedwork}
\input{conclusion}

{
  %\footnotesize
  \bibliographystyle{splncs04}
  \bibliography{bib/nicolas,bib/psutra,bib/mshapiro,bib/paper}
}

\clearpage
\appendix
\input{appendix}

\end{document}
