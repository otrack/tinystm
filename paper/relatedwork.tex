\section{Related Work}
\labsection{relatedwork}

Transactional memory (TM) allows to design applications with the help of sequences of instructions that run in isolation one from another.
This paradigm greatly simplifies the programming of modern highly-parallel computer architectures.

% blocking TM
Ennals \cite{emals} suggests to build deadlock-free lock-based TMs rather than non-blocking ones.
Empirical evidences~\cite{dice06} and theoretical results~\cite{Guerraoui:2008,KuznetsovR15} support this claim.

% permissiveness
At first glance, it might be of interest that a TM design accepts all correct histories; a property named \emph{permissiveness} \cite{guerraoui08}.
Such TM algorithms need to track large dependencies \cite{Keidar:2009} and/or acquire locks for read operations~\cite{attiya2012single}.
However, both techniques are known to have a significant impact on performance.

% validation
Early TM implementations (such as DSTM~\cite{herlihy2003software}) validate all the prior reads when accessing a new object.
The complexity of this approach is quadratic in the number of objects read along the execution path.
A time-based TM avoids this effort by relying on the use a global clock to timestamp object versions.
Zhang et al. \cite{zhang2008commit} compare several such approaches, namely TL2~\cite{dice2006transactional}, LSA \cite{riegel2006lazy} and GCC\cite{spear2006conflict}.
They provide guidelines to reduce unnecessary validations and shorten the commit sequence.

% single version, invisible read
Multi-versioning~\cite{Fernandes:2011, Diegues:2014} brings a major benefit: allowing read-only transactions to complete.
This clearly boosts certain workloads but managing multiple versions has a non-negligible performance cost on the TM internals.
Similarly, invisible reads ensure that read operations do not contend in most cases.
However, such a technique limits progress or the consistency criteria satisfied by the TM \cite{Attiya:2009}.
In the case of \refalg{stm}, both read-only and updates transaction are certain to make progress only in the absence of contention.

% DAP
New challenges arise when considering multicore architectures and cache coherency strategies for NUMA architectures.
Clock contention~\cite{6121290} is one of them.
To avoid this problem, workloads as well as TM designs should take into account parallelism~\cite{Nguyen:2017}.
Chan et al \cite{6121290} propose to group threads into zones, and that each zone shares a clock and a clock table.
To timestamp a new version, the TL2C algorithm \cite{Avni:2008} tags it with a local counter together with the thread id.
Each thread stores a vector of the latest timestamp it encountered.
The algorithm preserves opacity by requiring that a transaction restarts if one of the vector entries is not up to date.

%% \vs{add PODC'10 NUMA-aware TM ~\cite{Lu:2010:BAN:1835698.1835713}}
%% \vs{add ProteusTM~\cite{didona2016proteustm}}
%% \vs{add ~\cite{Mohamedin:2016:DNC:2851141.2851189}}
%% \vs{cite ~\cite{nguyen2017scalable}}

% Maintaining Consistent Transactional States without a Global Clock, Avni & Shavit
% space suage: O(m) per thread.
% each transaction got a vector clock inddicating the ts at which other transactions started
% each location got a timestamp pair (x.ts,x.owner), where x.owner is the thread that wrote x last.
% upon reading x, T compare x.ts to  its ts and abort if x.ts[x.owner] > T.ts[x.owner]
% no forward reading possible, thus more false abprt:
%
% This algorithm is SSER but has two main disadvantages
% 1) 
% ``We argue that a TLC transaction will always fail if it attempts 
% to read a location that was written by some other transaction after it started.''
% example of spurious abort: w_p(x).c_p.r_q(x).w_q(y).c_p.r_{q'}(y).a_{q'}.r_{q'}(x).a_{q'}
% the progress property of this STM is very weak, namely
% if the transaction starts from a quescient state and it repeatdly executed and there is no concurrent transaction, then it commits.
% 2) abortion due to non-causally consistent snapshot
% our appraoch does not have this problem


%% With multiple CPUs, each with its own clock, its impossible to guarantee that the crystals
%% don’t differ after some amount of time even when initially set accurately. In practice, all clocks
%% counters will run at slightly different rates. This clock skew brings several problems that can occur
%% and several solutions as well, some more appropriate than others in certain contexts.
%% The Time Stamp Counter was once an excellent high-resolution, low-overhead way for a program to get CPU timing information. With the advent of multi-core/hyper-threaded CPUs, systems with multiple CPUs, and hibernating operating systems, the TSC cannot be relied upon to provide accurate results — unless great care is taken to correct the possible flaws: rate of tick and whether all cores (processors) have identical values in their time-keeping registers. There is no promise that the timestamp counters of multiple CPUs on a single motherboard will be synchronize
%% Relying on the TSC also reduces portability, as other processors may not have a similar feature

%% Thanks for all the inputs: Here's the conclusion for this discussion: The TSCs are synchronized at the initialization using a RESET that happens across the cores and processors in a multi processor/multi core system. And after that every Core is on their own. The TSCs are kept invariant with a Phase Locked Loop that would normalize the frequency variations and thus the clock variations within a given Core and that is how the TSC remain in sync across cores and processors.

%% https://stackoverflow.com/questions/10921210/cpu-tsc-fetch-operation-especially-in-multicore-multi-processor-environment
%% https://github.com/dterei/tsc

%% PCL theorem

% the alg. of shvit et al. exhibits a very weak progress property, namely if the transaction is retried infinitely often it eventually commits.

%%   Computer designs that exploit data locality with multiple cache levels, such as non-uniform memory architectures (NUMA), have to reduce the amount of global operations to improve application performance or take special care to address traffic congestions\cite{dashti2013traffic}.

