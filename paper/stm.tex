\section{Algorithm}
\labsection{stm}

In this section, we present a transactional memory that attains $\SPSER$.
Contrary to several prior designs, our approach does not require a global clock.
It is weakly-progressive, aborting a transaction only when it encounters a concurrent conflicting transaction.
Moreover, the proposed approach ensures read invisibility, that is read operations do not modify the base objects of the implementation.

We first give an overview of the algorithm, present its internals and justify some design choices.
A correctness proofs follows.
We close this section with a discussion about the parameters of our algorithm.
In particular, we explain how to tailor it to be disjoint-access parallel.

\subsection{Overview}
\labsection{stm:overview}

\refalg{stm} depicts the pseudo-code of our construction of the TM interface at some process $p$.
Our design follows the optimistic approach of the lazy snapshot algorithm (LSA) \cite{FelberFMR10}, replacing the central clock with a more flexible mechanism.
%
To execute a write operation, process $p$ takes the corresponding lock then it buffers the update.
Upon executing a read, $p$ checks that the objects read so far did not change.
Similarly to LSA, this check is lazily executed.
Process $p$ executes it only when the timestamp associated with the new object read is higher than the current timestamp of the transaction.
At commit time, the read set of the transaction is validated then, if the transaction commits, its updates are applied to the shared memory.

\subsection{Tracking Time}
\labsection{stm:time}

\refalg{stm} tracks time to compute how concurrent transactions interleave during an execution.
To this end, the algorithm makes use of logical clocks.

We model the interface of a logical clock with two operations: $\cread$ returns a value in $\naturalSet$, and $\cadv(v \in \naturalSet)$ updates the clock with value $v$.
The sequential specification of a logical clock guarantees a single property, that the time flows forward:
\begin{inparaenum}
\item[\emph{(Time Monotonicity)}]
  A read operation always returns the greatest value to which the clock advanced so far, that is in every sequential history $h$, $(\responseAny{\cread}{v} \in h) \implies (v = \max{(\{u : \cadv(u) \hb_h \cread \} \union \{0\})})$.
\end{inparaenum}

\refalg{stm} associates logical clocks to both processes and transactions.
To retrieve the clock associated with some object $x$, the algorithm uses function $\clockOf{x}$.
Notice that in the pseudo-code, when it is clear from the context, $\clockOf{x}$ is a shorthand for $\clockOf{x}.\mathit{read}()$.

The clock associated with a transaction is always local (\refline{stm:var:1}).
In the case of a process, it might be shared or not (\refline{stm:var:2}).
The flexibility of the design comes from this locality choice for \clockOf{p}.
When the clock is shared, it is linearizable.
To implement a wait-free linearizable clock, we employ the following approach:
\begin{construction}
  Let $x$ be a shared register initialized to $0$.
  When $\cread$ is called, we return the value stored in $x$.
  Upon executing $\cadv(v)$, we fetch the value stored in $x$, say $u$.
  If $v > u$ holds, we execute a compare-and-swap to replace $u$ with $v$; 
  otherwise the operation returns.
  If the compare-and-swap fails, the previous steps are retried.
\end{construction}

\input{algorithms/stm.tex}

\subsection{Internals}
\labsection{stm:details}

In \refalg{stm}, each object $x$ has a \emph{location} in the shared memory, denoted $\locationOf{x}$.
This location stores a pair $(d,t)$, where $d$ is the content of $x$ as seen by transactions and $t \in \naturalSet$ is a \emph{timestamp}.
For simplicity, we shall name hereafter a pair $(d,t)$ a \emph{version} of object $x$.
Since the location of object $x$ is unique, a single version of object $x$ may exist at a time in the memory.
As usual, we assume some transaction $\transInit$ that initializes for every object $x$ the location $\locationOf{x}$ to $(\bot,0)$.
Furthermore, we consider that each read or write operation to some location $\locationOf{x}$ is atomic.

\refalg{stm} associates a lock to each object.
To manipulate the lock-related functions of object $x$, 
a process $p$ employs appropriately the functions $\lock{x}$, $\isLocked{x}$ and $\unlock{x}$.

For every transaction $T$ submitted to the system, \refalg{stm} maintains several local data structures:
\begin{inparaenumorig}[]
\item $\clockOf{T}$ is the logical clock of transaction $T$;
\item $\readSetOf{T}$ is a map that contains its read set;
\item $\writeSetOf{T}$ contains the write set; and
\item $\updateSetOf{T}$ buffers the updates made by $T$.
\end{inparaenumorig}
\refalg{stm} updates incrementally these variables over the course of the execution.
With more details, the execution of a transaction $T$ proceeds as follows.
\begin{itemize}
\item[-] %
  When $T$ begins its execution, \refalg{stm} initializes $\clockOf{T}$ to the smallest value of $\clockOf{q}$ for any process $q$ executing the TM.
  Then, the variables $\readSetOf{T}$, $\writeSetOf{T}$ and $\updateSetOf{T}$ are all set to $\emptySet$ (\reflines{stm:begin:1}{stm:begin:4}).
\item[-] %
  When $T$ reads a shared object $x$, if $x$ was previously written, its value is returned (\refline{stm:read:1}).
  Otherwise, \refalg{stm} fetches atomically the version $(d,t)$ from $\locationOf{x}$.
  Then, the algorithm checks that 
  \begin{inparaenum}
  \item no lock is held on $x$, and 
  \item in case $x$ was previously accessed, that $T$ observes the same version.
  \end{inparaenum}
  If one of these two conditions fails, \refalg{stm} aborts transaction $T$ (\refline{stm:read:5}).
  The algorithm then checks that the timestamp $t$ associated to the content $d$ is smaller than the clock of $T$.
  In case this does not hold (\refline{stm:read:6}), \refalg{stm} tries to extend the snapshot of $T$ by calling function $\stmExtend{}$.
  This function returns $\true$ when the versions previously read by $T$ are still valid.
  In which case, $\clockOf{T}$ is updated to the value $t$.
  If \refalg{stm} succeeds in extending (if needed) the snapshot of $T$, $d$ is returned and the read set of $T$ is updated accordingly;
  otherwise $T$ is aborted (\refline{stm:read:7}).
\item[-] %
  Upon executing a write request on behalf of $T$ to some object $x$, \refalg{stm} takes the lock associated with $x$ (\refline{stm:write:1}), and in case of success, it buffers the update in $\updateSetOf{T}$.
  \refalg{stm} also keeps track of the timestamp $t$ of the prior version of $x$.
  This timestamp is used to ensure that at commit time the timestamp of the new version of $x$ is greater than its previous value (\refline{stm:commit:2}).
\item[-] %
  When $T$ tries to commit, \refalg{stm} validates the read set by calling function $\stmExtend{}$ with the clock of $T$ (\refline{stm:try:1}).
  If this test succeeds, transaction $T$ commits (\reflines{stm:commit:1}{stm:commit:8}).
  In such a case, when $T$ is an update, \clockOf{T} ticks to reach its final value (\refline{stm:commit:3}).
  By construction, this value is greater than the timestamps of all the versions read or written by $T$ (\reflinestwo{stm:read:6}{stm:commit:2}).
  \refalg{stm} updates the clock of $p$ with the final value of \clockOf{T} (\refline{stm:commit:4}), then it updates the items written by $T$ with their new versions (\reflines{stm:commit:5}{stm:commit:7}).
\end{itemize}

\subsection{Guarantees}
\labsection{stm:guarantees}

In this section, we assess the core properties of \refalg{stm}.
%
For starter, let us notice that every function defined in \refalg{stm} is wait-free.
In addition, \refalg{stm} buffers the updates of some transaction $T$ in variable $\updateSetOf{T}$.
Hence, \refalg{stm} satisfies the model assumptions that are given in \refsection{criterion}.

\paragraph{(Progress)}
A transaction executes under \emph{weak progressiveness} \cite{Guerraoui:2009}, or equivalently it is \emph{weakly progressive}, when it aborts only if it encounters a conflicting transaction.
By extension, a TM is weakly progressive when it only produces histories during which transactions are weakly-progressive.
We prove that this property holds for \refalg{stm}.

In \refalg{stm}, a transaction $T$ may abort at lines~\ref{line:alg:stm:read:5}, \ref{line:alg:stm:read:7}, \ref{line:alg:stm:write:2}, \ref{line:alg:stm:write:5}, and \ref{line:alg:stm:try:2}.
We observe that in such a case either $T$ observes an item $x$ locked, or that the timestamp associated with $x$ has changed.
It follows that if $T$ aborts then it observes a conflict with a concurrent transaction.
From which we deduce that it is executing under weak progressiveness.

\paragraph{(Safety)}
Consider some run $\run$ of \refalg{stm}, and name $h$ the history produced in \run.
We let $\ll_h$ be the order in which the writes to the locations of the shared objects are linearized in $\rho$ (\refline{stm:commit:6}).
Hereafter, for some transaction $T_i$, we note $\clockOf{T_i}_f$ the final value of $\clockOf{T_i}$.

Below, we show that relation $<_h$ defined in \refsection{criterion:spser} is acyclic.
This characterization helps us to prove that if a transaction does not exhibit any unfair binding, then it observes a strictly consistent committed snapshot.
Further, we show that \refalg{stm} does not accept RC-anti-dependencies.

\begin{proposition}
  \labprop{stm:1}
  Consider two transactions $T_i$ and $T_{j \neq i}$ in $\committed{h}$ such that $r_i(x_j)$ occurs in $h$, or $x_i \ll_h x_j$ holds.
  Relation $\clockOf{T_i}_f \geq \clockOf{T_j}_f$ is true.
  Moreover, if $T_i$ is an update, the ordering is strict, i.e., $\clockOf{T_i}_f > \clockOf{T_j}_f$.
\end{proposition}

\begin{proof}

  We show that $\clockOf{T_i} \geq \clockOf{T_j}_f$ holds at \refline{stm:commit:2}, if $T_i$ is an update, and at \refline{stm:commit:1} otherwise.
  \begin{itemize}
  \item ($r_i(x_j) \in h$)\\
    We observe that $T_j$ writes version $x_j$ together with $\clockOf{T_j}_f$ at $\locationOf{x}$ upon committing (\refline{stm:commit:6}).
    Because $T_i$ and $T_j$ are distinct transactions, $T_i$ must return from the read at \refline{stm:read:9}.
    When this occurs, $T_i$ has assigned $\clockOf{T_j}_f$ to $t$ before at \refline{stm:read:2}.
    The condition at \refline{stm:read:6} implies that either $\clockOf{T_i} \geq t$ holds, or a call to $\stmExtend{T_i,t}$ occurs.
    In the latter case, transaction $T_i$ executes \refline{stm:extend:5}, advancing its clock up to the value of $t$.
  \item ($x_j \ll_h x_i$)\\
    Clearly, it suffices to show the claim when $x_i$ immediately follows $x_j$ in the version order.
    %
    When $T_j$ returns from $w_j(x_j)$ at \refline{stm:write:5}, it holds a lock on $x$.
    This lock is released at \refline{stm:commit:7} after writing to $\locationOf{x}$.
    As $\ll_h$ follows the linearization order, $T_i$ executes \refline{stm:write:1} after $T_j$ wrote $(x_j, \clockOf{T_j}_f)$ to $\locationOf{x}$.
    Location $\locationOf{x}$ is not updated in the between.
    Thus, after transaction $T_i$ executes \refline{stm:write:4}, $\writeSetOf{T}$ contains $(x,\clockOf{T_j}_f)$.
    It follows that after \refline{stm:commit:2}, $\clockOf{T_i} \geq \clockOf{T_j}_f$ is true.
  \end{itemize}
  Since a clock is monotonic, the above ordering holds forever.
  %
  Then, if transaction $T_i$ is an update, it executes \refline{stm:commit:3}, leading to $\clockOf{T_i}_f > \clockOf{T_i}_f$.
\end{proof}

\begin{proposition}
  \labprop{stm:3}
  Consider two transactions $T_i$ and $T_{j \neq i}$ in $\committed{h}$.
  If $T_i \closureOf{<_h} T_j$ holds, transaction $T_i$ invokes $\stmTryCommitFunction$ before transaction $T_j$ in $h$.
\end{proposition}

\begin{proof}
  It suffices to show that this property is true when $T_i <_h T_j$ holds.
  Below, we consider each of the four cases defining relation $<_h$.
  \begin{compactitem}
  \item ($T_i \hb_h T_j$)\\
    This case is immediate.
  \item ($\exists x : r_j(x_i) \in h$)\\
    Since $T_j$ reads version $x_i$ in history $h$, it should retrieve $(x_i,\clockOf{T_i}_f)$ from $\locationOf{x}$ when executing \refline{stm:read:2}.
    Hence, transaction $T_i$ has already executed \refline{stm:commit:6} on object $x$.
    It follows that $T_i$ invokes $\stmTryCommitFunction$ before transaction $T_j$ in $h$.
  \item ($\exists x : x_i \ll_h x_j$)\\
    By definition of $\ll_h$, the write of version $x_i$ is linearized before the write of version $x_j$ in $\rho$.
    After $T_i$ returns from $w_i(x_i)$, it owns a lock on object $x$ (\refline{stm:write:1}).
    The object is then unlocked by transaction $T_i$ at \refline{stm:commit:7}.
    As a consequence, transaction $T_j$ takes a lock on object $x$ after $T_i$ invokes the helper $\stmCommitFunction$.
    From which it follows that the claim holds.
  \item ($\exists x, T_k : x_k \ll_x x_j \land r_i(x_k)$)\\
    (By contradiction.)
    When $T_j$ invokes $\stmTryCommitFunction$, it holds a lock on $x$.
    This lock is released at \refline{stm:commit:7} after version $(x_j,\clockOf{T_j}_f)$ is written at location $\locationOf{x}$.
    %
    Then, consider the time at which $T_i$ invokes $\stmTryCommitFunction$.
    The call at \refline{stm:try:1} leads to fetching $\locationOf{x}$ at \refline{stm:extend:2}.
    Since $T_i$ reads version $x_k$ in $h$, a pair $(x_k,\clockOf{T_k}_f)$ is in $\readSetOf{T_i}$.
    From the definition of $\ll_h$ the write of $(x_k,\clockOf{T_k}_f)$ takes place before the write of version $(x_j,\clockOf{T_j}_f)$ in $\rho$.
    Thus, object $x$ is locked at the time transaction $T_i$ invokes $\stmTryCommitFunction$, or $\locationOf{x}$ contains some version $(x_l,\clockOf{T_l}_f)$ with $x_k \ll_h x_l$.
    From \refprop{stm:1}, we have $\clockOf{T_l}_f > \clockOf{T_k}_f$.
    It follows that transaction $T_i$ executes \refline{stm:extend:4} and aborts at \refline{stm:try:3}.
  \end{compactitem}
\end{proof}

\begin{theorem}
  \labtheo{spser}
  History $h$ belongs to $\SPSER$.
\end{theorem}

\begin{proof}
  \refprop{stm:3} tells us that for any two transactions $T_i$ and $T_j$ in $\committed{h}$, if $T_i <_h T_j$ holds then $T_i$ invokes $\stmTryCommitFunction$ before $T_j$.
  As a consequence, the real-time serialization graph $\RSG(h,\ll_h)$ is acyclic.

  Let us now turn our attention to the second property of $\SPSER$.
  Assume that a transaction $T_i$ aborts in $h$.
  For the sake of contradiction, consider that $T_i$ does not observe a strictly consistent snapshot, yet that all of its binding are fair.
  
  Applying the definition given in \refsection{criterion:spser}, relation $<_h$ is cyclic starting from $\{T_i\}$.  
  Hence, there exist transactions $T_j$ and $T_k$ such that $T_j \closureOf{<_h} T_i$, $r_i(x_k)$ occurs in $h$ and $x_k \ll_h x_j$.
  From \refprop{stm:3}, if $T_j \hb_{h} T_i$ holds, transaction $T_i$ cannot observe version $x_k$.
  Thus, there must exist some transaction $T_l \in \committed{h}$ (possibly $T_j$) and some object $y$ such that $T_i$ performs $r_i(y_l)$ and $T_j \closureOf{<_h} T_l$.

  In what follows, we prove that $T_i$ cannot read both versions $y_l$ or $x_k$. 
  For starter, relation $<_{\committed{h}}$ is acyclic, thus $x_k \neq y_l$ holds.
  It remains to investigate the following two cases:
  \begin{itemize}
  \item ($r_i(y_l) \hb_h r_i(x_k)$)\\
    Since $T_j \closureOf{<_h} T_l$ is true, \refprop{stm:3} tells us that $T_j$ invokes $\stmTryCommitFunction$ before transaction $T_l$.
    Thus, $T_j$ has invoked $\stmTryCommitFunction$ at the time $T_i$ reads object $x$.
    It follows that transaction $T_i$ does not return version $x_k$ in history $h$.
  \item ($r_i(x_k) \hb_h r_i(y_l)$)\\
    We show that, before returning $y_l$, when $T_i$ executes \refline{stm:read:2} to read some object $z$, the timestamp stored at $\locationOf{z}$ is greater than $\clockOf{T_i}$ and transaction $T_j$ has already invoked $\stmTryCommitFunction$.
    
    \begin{claim}
      There exists a transaction $T_n$ such that
      \begin{inparaenum}
      \item $r_i(z_n)$ occurs in $h$,
      \item $T_n$ is concurrent to $T_i$,
      \item if $T_n \neq T_j$ then $T_n$ calls $\stmTryCommitFunction$ after $T_j$, and
      \item for every read operation $r_i(a_m) \hb_h r_i(z_n)$, $T_n$ calls $\stmTryCommitFunction$ after $T_m$.
      \end{inparaenum}
    \end{claim}

    \begin{proof}
      Transaction $T_j$ satisfies all the properties but \emph{(iv)}.
      %
      In details, \refprop{stm:3} tells us that $T_l$ calls $\stmTryCommitFunction$ after $T_j$.
      Moreover, as $x_k \ll_h x_j$ holds, $T_j$ calls $\stmTryCommitFunction$ after the invocation of $r_i(x_k)$.
      On the other hand, the read $r_i(y_l)$ is committed.
      It follows that $T_l$ calls $\stmTryCommitFunction$ before or concurrently to this read.
      Hence, $T_j$ is concurrent to $T_i$.
      %
      If for every preceding read $r_i(a_m)$, $T_j$ calls $\stmTryCommitFunction$ after $T_m$, we let $T_n$ be transaction $T_j$.
      Otherwise, $T_n$ is the first transaction such that $r_i(a_{m}) \hb_h r_i(y_l)$ and $T_m$ calls $\stmTryCommitFunction$ after $T_j$.
      % this transaction satisfies (i) obviously, (ii) comes from the fact that the call to stmTryCommitFunction occurs before the invocation of r_i(y_l).
      % (iii) is implied by being the first s.t. 
    \end{proof}

    \begin{claim}
      Relation $\clockOf{T_i} < \clockOf{T_n}_f$ holds when $\stmBegin$ returns for $T_i$.
    \end{claim}
    
    \begin{proof}
      Observe that $T_n$ has not invoked $\stmTryCommitFunction$ at the time $T_i$ begins its execution.
      % because T_n commits after T_j (or equals) and r_i(x_k) occurs in h.
      Hence, denoting $q$ the process that executes $T_j$, $\clockOf{q} < \clockOf{T_n}_f$ is true when $T_i$ begins its execution.
      Thus, from the pseudo-code at \reflines{stm:begin:1}{stm:begin:3}, $\clockOf{T_i} < \clockOf{T_n}_f$ holds when $\stmBegin$ returns for $T_i$.
    \end{proof}
    
    Choose $T_n$ as defined above.
    Property \emph{(i)} and \emph{(ii)} above inform us that $T_i$ is bound to $T_n$.
    Applying property \emph{(iv)} and the fact that every binding is fair, if $r_i(a_m) \hb_h r_i(z_n)$ holds, then $T_n \depends T_m$ must be true.
    By \refprop{stm:1}, we have $\clockOf{T_m}_f > \clockOf{T_n}_f$, for every such transaction $T_m$.
    It follows that when $T_i$ executes $r_i(z_n)$ the timestamp fetches from $\locationOf{z}$ is greater than $\clockOf{T_i}$.
    % FIXME 
    Moreover, by property \emph{(iii)}, transaction $T_j$ has invoked $\stmTryCommitFunction$ at that time.

    From what precedes, transaction $T_i$ invokes \stmExtendFunction at \refline{stm:read:6} when reading object $z$.
    Because $T_j$ has already invoked $\stmTryCommitFunction$, the test at \refline{stm:extend:3} fails.
    It follows that $T_i$ aborts before returning $y_l$.
  \end{itemize}
\end{proof}

\begin{proposition}
  \labprop{stm:2}
  History $h$ does not exhibit any RC-anti-dependencies ($h \notin \RCAD$)
\end{proposition}

\begin{proof}
  Consider $T_i$, $T_j$ and $T_k$ such that $r_i(x_k), w_j(x_j) \in h$, $x_k \ll_h x_j$ and $T_j$ commits before $T_i$.
   %
  When $T_j$ invokes $\stmTryCommitFunction$, it holds a lock on $x$.
  This lock is released at \refline{stm:commit:7} after version $x_j$ is written at location $\locationOf{x}$.
  %
  Then, consider the time at which $T_i$ invokes $\stmTryCommitFunction$.
  The call at \refline{stm:try:1} leads to fetching $\locationOf{x}$ at \refline{stm:extend:2}.
  From the definition of $\ll_h$ the write of $(x_k,\clockOf{T_k}_f)$ takes place before the write of version $(x_j,\clockOf{T_j}_f)$ in $\rho$.
  Hence, if $T_j$ invokes $\stmTryCommitFunction$ before $T_i$, $\locationOf{x}$ does not contain anymore $(x_k,\clockOf{T_k}_f)$.
  Applying \refprop{stm:1}, $T_i$ executes \refline{stm:extend:4} and aborts at \refline{stm:try:3}.
\end{proof}

\subsection{Discussion}
\labsection{stm:discussion}

\refalg{stm} replaces the global clock commonly found in TM designs with a more flexible mechanism.
For some process $p$, \clockOf{p} can be local to $p$, shared across a subset of the processes, or even all of them.

If processes need to synchronize too often, maintaining consistency among the various clocks is expensive.
In this situation, it might be of interest to find a compromise between the cost of cache coherency and the need for synchronization.
For instance, in a NUMA architecture, \refalg{stm} may assign a clock per hardware socket.
Upon a call to $\clockOf{p}$, the algorithm returns the clock defined for the socket in which the processor executing process $p$ resides.

On the other hand, when processes use a global clock, \refalg{stm} boils down to the original TinySTM implementation \cite{FelberFMR10}..
In this case, a read-only transaction always sees a strictly consistent committed snapshot.
As a consequence, it can commit right after a call to $\stmTryCommitFunction$, i.e., without validating its read set at \refline{stm:try:1}.

A last observation is that our algorithm works even if one of the processes takes no step.
This implies that the calls to processes' clocks (at \reflinestwo{stm:begin:1}{stm:commit:4}) are strictly speaking not necessary and that it can be skipped without impacting the correctness of \refalg{stm}.
Clocks are solely used to not revalidate the read set at each step.
If process clocks are not used, when two transactions access disjoint objects, they do not contend on any base object of the implementation.
As a consequence, such a variation of \refalg{stm} is disjoint-access parallel (DAP).
