
%% % Clock

%% \clock \equaldef \{ \cadv(n \in \tickSet) \}
%% seq. specification of \cadv(n):
%% \cadv(n) \assign \if \ts < n \then \ts \assign \ts \assign n 
%% we prove that a composite clock is still a clock 

%% % Cons. clock

%% (h,\hb) \subset (h,w_{\Theta})

%% % Cons. snap

%% \{x_i, y_j\} cons. \equaldef 
%% w_j(x_j) \in h \implies x_j \hb x_i 
%% \land
%% w_i(y_i) \in h \implies y_i \hb y_j

%% S cons. \equaldef
%% \forall x_i, y_j \in S : \{x_i, y_j\} cons.

%% S cons_{\Theta} \impliesS S cons_{\hb}

%% % Stalling clock

%% \stalling \Theta
%% \equaldef
%% \forall e,e' \in h : \Theta(e) \leq \Theta(e')

%% % Synchronized clocks

%% \Theta_a  \sync \Theta_b
%% \equaldef
%% \forall e, e' \in h : \Theta_a(e) = \Theta_a(e') \implies \Theta_b(e) < \Theta_b(e')

%% \sync \Theta_a \Theta_b 
%% \equaldef
%% \Theta_a  sync \Theta_b \land \Theta_b  sync \Theta_a

%% % Composite clocks

%% \Theta(e) \equaldef \max \Theta_a(e), \Theta_b(e)

%% ( \Theta_a cons. \land \Theta_b cons. ) \implies \Theta_e cons
%% [[ trivial. ]]

%% ( \stalling \Theta_a \land \stalling \Theta_b \land \sync \Theta_a \Theta_b ) \implies \Theta_e cons.
%% [[ trivial. ]]

%% % Building synchronized clocks:

%% F \in A, B

%% \switch f \in \flagSet
%% \assigns
%% \if \cas F f+1 f \then 
%% \cadv \Theta_f \cread \Theta_{f+1}

%% \cadv t \in \tickSet
%% \assigns
%% \cadv \Theta_F t

%% \cread 
%% \assings
%% \cread \Theta_F 


%% \subsection{Fast Commitment of Queries}
%% \labsection{stm:query}

%% Provided that the read-set is known in advance, \refalg{stm} can quickly commit read-only transactions (queries).
%% More precisely, \refalg{stm} leverages the additional information given by the read-set 
%% to avoid the preemptive abort that occurs at \reflinestwo{stm:7}{stm:9}.
%% In detail, when a query $T$ accesses in order items $\langle o_1, \ldots, o_m \rangle$, 
%% \refalg{stm} executes $T$ following the pseudo-code at \reflines{stm:4}{stm:11},
%% but upon aborting due to an item $o_i$ having a timestamp $t>\clockOf{T}$, instead the revalidates all the items $o_{1<j<i}$.
%% This mechanism ensures that for every query $T$, provided no concurrent conflicting executes, $T$ eventually commits.
%% From the the impossibility result of \citet{DBLP:conf/spaa/AttiyaHM09}, this is the strongest liveness property we can achieve
%% since queries in \refalg{stm} are invisible and our algorithm ensures the DAP property,

%% \subsection{Moving Locks}
%% \labsection{stm:locks}

%% In a NUMA architecture, memory access time depends on the memory location relative to a processor.
%% Similarly to a cache, a processor accesses its own local memory faster than non-local memory.
%% To leverage this architecture, \refalg{stm} can remap on the fly the memory location of the locks.
%% Below, we describe how we achieves this.

%% \refalg{stm} associates to each cluster of processes $c$ a lock table $L[c]$ in the memory local to $c$.
%% The lock associated to some object $o$ is accessed by an indirection.
%% Initially $L[c]$ is empty for each cluster, and for every object $o$, 
%% the location of the lock associated (by indirection) to $o$ is kept in the same location as the metadata of $o$.
%% When a process $p$ executes functions \lock{}, \isLocked{} and \unlock{} on some data item $o$,
%% $p$ first checks in $L[c]$ if the lock associated to $o$ is present. 
%% In case the lock is present and its location contains a value different than $\bot$, $p$ accesses it.
%% Otherwise, $p$ accesses the location of the lock associated to $o$ by retrieving it from the metadata.
%% Then, if $p$ locks $o$, it moves the lock associated to $o$ as follows.
%% First, $p$ inserts the lock into the table $L[c]$.
%% Then, it changes the value of the direction to the location of the lock of $o$ in $L[c]$.
%% Finally, $p$ assigns the value contained in previous location to $\bot$.

%% Because every cluster of processes may eventually holds a large amount of locks in its local memory,
%% the previous schema can be expensive in terms of memory.
%% To mitigate this problem, \refalg{stm} treats $L[c]$ as a bounded FIFO queue.
%% A process $p$ removes a location from $L[c]$ when it is either invalid or outdated.
%% In the later case, the content of the lock is moved back into the metadata of the associated object.


Let $T$ and $T'$ be two transactions in $h$ with $(T,T') \in G_h$.
First of all, we observe that \emph{(F1)} if $T$ reads a version $x_i$ of some item $x$ written by $T'$, 
transaction $T$ must have committed in $h$ before (\refline{stm:36}).
Moreover, our timestamping system ensures that for any two causally-related versions $x_i$ and $y_j$,
the timestamp of $y_j$ is greater than the timestamp of $x_i$.
From this observation, we can establish that \emph{(F2)} for every transaction $T$, 
at all time during $h$ the snapshot read by $T$ is consistent.
In what follows, we prove that \emph{(F3)} if both $T$ and $T'$ commit then $T$ commits before $T'$ in $h$ , i.e., 
denoting $p$ and $q$ the processes that execute respectively $T$ and $T'$ in $h$, 
we have $\response{p}{\stmCommit{T}}{} <_h \invocation{q}{\stmCommit{T'}}{}$.
The conjunction of facts F1, F2 and F3 implies that $G_h$ is both well-formed acyclic, 
from which we deduce that history $h$ is opaque.

  %% According to the code of \stmRead{}, at the time $T'$ reads $x$, 
  %% the item is unlocked and it contains version $x_i$ (\reflinestwo{stm:5}{stm:6}).
  %% Hence at that time, transaction $T$ has committed.
  
  %% Name $T_k$ the version read by $T_i$.
  %% If $T_i=T_k$ then  

  %% This means that there exists an item $x$ and two versions $x_i$ and $x_j$ of $x$
  %% such that $T$ reads version $x_i$, $T'$ writes version $x_j$, and $x_i$ precedes $x_j$ in the version order.
  %% At the time transaction $T$ reads $x$, $T'$ has not executed its write yet and thus it should commit later on.
  %% Then, for the sake of contradiction, assume $\invocation{q}{\terminate{T'}}{} <_h \response{p}{\terminate{T}}{}$.
  %% This means that at the time $T$ terminates, either $x$ is locked by $T'$, or a version posterior or equal to $x_i$ is installed in $x$.
  %% The pseudo-code at \reflines{stm:15}{stm:32} implies that in both cases $T$ aborts;
  %% a contradiction.


  %% The pair $(T,T')$ denotes a versioning relation, that is, 
  %% both transactions write to $x$ in $h$, $T$ preceding $T'$.
  %% In this case, at the time $T'$ writes to $x$, $x$ is unlocked (\refline{stm:20}), 
  %% and $T$ must have committed previously.
  %% Hence, our claim holds.
  %% We notice here that in such a case, 
  %% the timestamp associated to the version $x_i$ of $x$ is greater than the timestamp associated to $x_j$ (\refline{stm:38}).



%% Let $\ll$ be any linearization of $h$.
%% We denote by $G_h=(h,\ll,\emptySet)$ the opacity graph induced by $h$ and the order $\ll$.

%% \begin{proposition}
%%   \labprop{opa:graph}
%%   The graph $G_h=(h,\ll,\emptySet)$ is well-formed and acyclic.
%% \end{proposition}

%% \begin{proof}

%%   First of all, we show that $G_h$ is well-formed.
%%   **FIXME

%%   Next, we prove that if $(T_i,T_j) \in G_h$ then $T_i \ll T_j$ holds.
%%   By definition of an opacity graph \cite{Guerraoui:2008}, 
%%   an edge $(T_i,T_k)$ in $G_h$ exists in one of the following four cases.
%%   \begin{inparaenum}[\em(i)]
%%   \item %
%%     Transaction $T_i$ is executed before $T_j$ in $h$, 
%%     from which it follows immediately that $T_i < T_j$.
%%   \item %
%%     The edge $(T_i,T_j)$ captures a read-from dependency in $h$, that is, for some item $x$,
%%     $T_j$ writes a version $x_j$ of $x$ while $T_j$ reads it.
%%     Here again, by definition of $<$, we may conclude $T_i < T_j$.
%%   \item %
%%     In this third case, the edge $(T,T')$ captures an anti-dependency relation.
%%     By definition, $T_i$ reads some register written by $T_j$ and relation $T_i \ll T_j$ should hold.
%%   \item %
%%     The last case captures that transaction $T_i$ is (pending or) committed 
%%     and that there exists a transaction $T_m$ and a register $x$ 
%%     such that $T_i \ll T_m$, $T_i$ writes to $x$, and $T_m$ reads $x$ from $T_j$.
%%     In other words, transaction $T_m$ witnesses a version order between transaction $T_i$ and $T_j$.
%%     %
%%     Since transactions $T_i$ and $T_j$ both write to register $x$, either $T_i \ll T_j$ or the converse holds.
%%     Assume that $T_j \ll T_i$ holds.
%%     Applying \refprop{opa:clock} to relations $T_j \ll T_i$ and $T_i \ll T_m$, 
%%     we deduce $\clockOf{T_j}_f \leq \clockOf{T_m}_f$.
%%     A contradiction.
%%   \end{inparaenum}

%%   From what precedes and the fact that $\ll$ is an order, we deduce that $G_h$ is acyclic.

%% \end{proof}


    From the code at \refline{stm:read:1}, we know that $t=\clockOf{T_i}_f$ holds.
    Then, if $t > \clockOf{T_j}$ holds, transation $T_j$ is extended with timestamp $t$ at \refline{stm:read:5}.
    Since transaction $T_j$ commits this call succeeds, leading to $\clockOf{T_j} = t$.
    Hence at that point in time, $\writeSetOf{T_i}[x] = \readSetOf{T_j}[x]$.
    Because $T_j$ cannot read another version of $x$ later on (\refline{stm:extend:3}), this invariant holds forever.
