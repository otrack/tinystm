\section{A new consistency criteria}
\labsection{criteria}

In what follows, we present the elements of our system model, as commonly found in textbooks (e.g., \cite{}).
Then, we formulate our notion of stricter serializability.

\subsection{System Model}
\labsection{criteria:model}

Software transactional memory (STM) is a recent paradigm that allows multiple processes to access concurently a memory region.
Each process manipulates \emph{objects} in the shared memory with the help of transactions.
When a process begins a new transaction, it calls function \stmBeginFunction.
Then, it executes a sequence of \stmReadFunction and \stmWriteFunction operations on the shared objects according to some internal (not modeled) logic.
Operation \stmRead{x} takes as input an object $x$ and returns either a value in the domain of $x$, or a flag $\flagAbort$ to indicate that the transation aborts.
A write \stmRead{x,v} changes $x$ to the value $v$ in the domain of $x$.
This operation does not return any value and it may also abort.
At the end of the execution, the process calls \stmTryCommitFunction to terminate the transaction.
This calls returns either $\flagCommit$, to indicate that the transaction commits, or $\flagAbort$ if it aborts.

A \emph{history} is a sequence of invocations and responses of the tranasctional operations by one or more processes.
As illustrated below, a history is commonly represented with parallel timelines, where each timeline represents the transactions executed by some processes.
In history $h_2$, process $p$, $q$ and $r$ execute respectively transactions ${\color{blue}{T_1}}=w(x)$, ${\color{red}{T_2}}=w(x)$ and ${\color{OliveGreen}{T_3}}=r(x)$.
All the transactions but $T_4$ completes in this history.
For simplicity, complete transactions that are not explicitely aborted in a history commit immediately after their last operations.
We note $\committed{h}$ the set of transactions that commit during history $h$.
In the case of history $h_2$, we have $\committed{h_2}=\{T_1,T_2,T_3\}$.

\input{figures/sample}

A history induces a real-time order between transactions (denoted $\hb_h$).
This order holds between transactions $T_i$ and $T_j$ when $T_i$ terminates in $h$ before $T_j$ begins.
For instance in history $h_2$, transaction $T_1$ precedes transaction $T_3$.
When two transactions are not related with real-time, they are \emph{concurrent}.


A \emph{version} is the state of a shared object as produced by the write of a transaction.
When transaction $T_i$ writes to some object $x$, an operation denoted $w_i(x_i)$, it creates a new version $x_i$ of $x$.
Versions allow to uniquely identify the state of an object as observed by a read operation, \emph{e.g.}, $r_3(x_1)$ in $h_2$.
When a transaction $T_i$ reads version $x_j$, we say that $T_i$ \emph{read-from} transaction $T_j$.

Given some history $h$ and some object $x$, a version order on $x$ for $h$ is a total order relation over the versions of $x$ in $h$.
By extension, a version order for $h$ is the union of all the version orders for all objects (denoted $\ll_h$).
For instance, in history $h_2$ above,  we may consider the version order $(x_1 \ll_{h_2} x_2)$.

A transaction $T_i$ \emph{depends on} some transaction $T_j$, written $T_i \depends T_k$ when $T_j$ precedes $T_i$, $T_i$ reads-from $T_j$, or such a relation holds transitively.
A transaction observes a \emph{strictly consistent snapshot} \cite{berstein?} when it never misses the effects of some transaction it depends on.
In other words, the snapshot of transaction $T_i$ in history $h$ is strictly consistent when
\begin{inparaenum}
\item $T_i$ reads version $x_j$,
\item $T_k$ writes version $x_k$, and 
\item $T_i$ depends on $T_{k}$,
\end{inparaenum}
then version $x_k$ is followed by version $x_j$.
Formally, $((r_i(x_j) \in h) \land (w_k(x_k) \in h) \land (T_i \depends T_k)) \implies (x_k \ll_{h,x} x_j)$, where $\ll_{h}$ is some version order defined over history $h$.

\subsection{Contention and bindings}
\labsection{criteria:bindings}

Internally, a transaction memory is built upon a set of \emph{base objects}, such as locks.
When two transactions are concurrent, their steps on these base objects are interleaving.
If the two transactions access disjoint objects and the TM is disjoint-access parallel, no contention occurs.
However, in the case they access the base object, they may slow down each other.

A transactional read is \emph{invisible} when it does not change the state of the base objects implementing it.
With invisible reads, read contention is basically free.
Conversely, if the two transactions are concurrently writing, it is possible to detect the contention and abort. % preventively.
When a read-write conflict occurs, a \emph{race condition} occurs between the reader and the writer.
If the read operation takes place after the write, the reader is bound to use the version produced by the writer.

\begin{definition}[Binding]
  When a transaction $T_i$ reads-from a concurrent transaction $T_j$, we say that $T_i$ is bound to $T_j$ on $x$.
\end{definition}

When a transaction $T_i$ is bound to another transaction $T_j$, to preserve the consistency of its snapshot, $T_i$ must read the updates and causal dependencies of $T_j$ that are intersecting with its read set.
This is for instance the case of transaction $T_4$ in history $h_2$, where this transaction is bound to $T_3$ on $y$.
As a consequence, $T_4$ must return $x_1$ as the result of its read on $x$, or its snapshot will be inconsistent.

Tracking this causality relation is difficult for the conention manager as it requires to inspect the readset, rely on a global clock, or use large amount of metadata \cite{}.
We observe that it is simpler if the items read prior the binding are either, also read by the writer, or by someof its dependencies.
In which case, we will say that the binding is fair.

\begin{definition}[Fair binding]
  Consider that a transaction $T_i$ is bound to a transaction $T_j$ on some object $x$.
  This binding is \emph{fair} when, for every object $y$ accessed before $x$, either $y$ is accessed by $T_j$ or by one of its dependencies.
\end{definition}

Going back to history $h_3$, the binding of $T_4$ to $T_3$ on $y$ is fair.
Indeed, this transaction did not read any data item before accesing the version of $y$ written by $T_4$.
When the binding is fair, the reader can leverage the metadata left by the writter to check prior versions it has read and ensure the consistency of later read operations.
In the next section, we formalize this idea with the notion of stricter serializability.

\subsection{Stricter serializability}
\labsection{criteria:spser}
Here we introduce and describe in details \sser, the stricter serializability consistency criteria that we build upon in the remainder of this paper.
%is a stronger consistency criteria than strict serializability (\textsc{SSer}).
The \sser criteria requires that committed transactions form a sequential history.
In addition, \sser prohibits transactions to view inconsistencies unless one of their bindings is unfair.
Inline with prior art \cite{berstein,opa}, we give a graph characterization of stricter serializability.

\begin{definition}[Strict Serialization graph]
  Consider some version order $\ll_h$ for $h$.
  We note $<$ the various relations over $\committed{h}$ induced by $\ll_h$, as defined below.
  The serialization graph of history $(h,\ll_h)$ is defined as $(\committed{h},<)$.
  \begin{displaymath}
    \begin{array}{l}
      \forall T_i, T_j \in \committed{h} : 
      T_i < T_{j \neq i}  \equaldef \\
      \lor~ T_i \hb_h T_j {\hspace{16.8em}\text{(1)}} \\
      \lor~ \exists x : \lor~ r_j(x_i) \in h {\hspace{13.3em}\text{(2)}} \\
      \hspace{2.9em}\lor~ \exists T_k : x_k \ll_{h,x} x_j \land \lor~T_k = T_i {\hspace{5em}\text{(3)}} \\
      \hspace{12.2em} \lor~ r_i(x_k) \in h {\hspace{3.9em}\text{(4)}}
    \end{array}
  \end{displaymath}  
\end{definition}
In the above definition, (1) is a real-time order between $T$ and $T'$, (2) a read-write dependency, (3) a version ordering, and (4) an anti-dependency.

\begin{definition}[Stricter serializability]
  A history $h$ is stricter serializable ($h \in \SPSER$) when
  \begin{inparaenum}
  \item for some version order $\ll_h$, the serialization graph $(\committed{h},<)$ is acyclic, and
  \item for every transaction $T_i$ that aborts in $h$, either $T_i$ observes a strictly consistent snapshot in $h$, or one of its bindings is unfair.
  \end{inparaenum}
\end{definition}

Opacity ($\OPA$) and strict serializability ($\SSER$) coincide when no transaction abort during an history.
As a consequence of the above definition, if in a stricter serializable history all the aborted transaction exhibit fair bindings, the history is opaque.

\begin{corollary}
  \labcor{criteria:1}
  If ($h \in \SPSER$) exhibits no unfair bindings then ($h \in \OPA$) holds.
\end{corollary}

\refcor{criteria:1} offers a properties on histories which, provided it aplies, allows to reach opacity.
Based on this property, the section that follows presents a \emph{robustness} analysis against $\SPSER$.
This means that we give a static analysis of workloads for which this property applies.

\subsection{Applicability}
\labsection{criteria:applicability}

The state of an object commonly include a reference to another object.
These references between objects form the \emph{object graph} of the application.
Processes know initially one (or more) \emph{root} objects in this graph, and upon performing a computation traverse the object graph appropriately.

Consider that a transaction $T$ access in order objects $x_1, \ldots, x_m$.
We say that $T$ executes a \emph{simple traversal} if for all $i \in [1,m-1]$, the state of $x_i$ includes a reference to $x_{i+1}$.
Let us call $P$ the following property on the application.

\begin{itemize}
\item[($P$)]
  The object graph forms initially a forest and every transaction maintains this invariant.
  Moreover, every transaction in the application executes a simple traversal.
\end{itemize}

The proposition below proves that, if $\mathcal{P}$ holds, then the application is robust against $\SPSER$.

\begin{proposition}
  Consider some set of transaction $\mathcal{T}$ for which property $P$ holds.
  Define $H_{\mathcal{T}}$ the histories form using transaction in $\mathcal{T}$.
  Then, it is true that $\SPSER \inter H_{\mathcal{T}} \subset \OPA$.
\end{proposition}

\begin{proof}
  Choose some history $h \in H_{\mathcal{T}} \inter \SPSER$, and let $T_i$ be a transaction that aborts in $h$.
  %% We prove by induction that each of the bindings of $T_i$ is fair in $h$.
  %% To this end, we consider all the reads executed by $T_i$, following the order $\hb_h$.  
  From the definition of $\SPSER$, one of the bindings of $T_i$ is fair in $h$.
  Define $x$ and $T_j$ such that
  \begin{inparaenum}
  \item $T_i$ is bound to $T_j$ on $x$, and
  \item $x$ is the first object read by $T_i$ for which this binding is unfair.
  \end{inparaenum}
  
  Since $h \in \SPSER$ holds, then $\committed{h}$ is equivalent to a sequential history $\lambda$.
  By definition of $x$, there exists a position $p$ in $\lambda$ after $T_j$ where we may put the execution of $T_i$ in $h$ up to $r_i(x)$.
  This gives us history $\hat{\lambda}$.
  In this history,
  transaction $T_j$ precedes transaction $T_i$,
  transation $T_i$ observes a strictly consistent snapshot.
  For each object $x^k$ accessed by $T_i$ before $x$, we prove that
  either $T_j$ accesses $x^k$, or one of its dependency access it.
  (By induction.)
  $x^1$ is a root

  if $T_j$
  
  
\end{proof}
