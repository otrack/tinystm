\section{A new consistency criteria}
\labsection{criteria}

In what follows, we present the elements of our system model, as commonly found in textbooks (e.g., \cite{}).
Then, we formulate our notion of stricter serializability.

\subsection{System Model}
\labsection{criteria:model}

Software transactional memory (STM) is a recent paradigm that allows multiple processes to access concurently a memory space.
Each process manipulates registers in the shared memory with the help of transactions.
When a process begins a new transactions, it calls function \stmBeginFunction.
Then, it executes a sequence of \stmReadFunction and \stmWriteFunction operations on the registers according to some internal (not modeled) logic.
At the end of the execution, the process calls \stmTryCommitFunction to terminate the transaction, in which case the transaction may either commit ($\flagCommit$), or abort ($\flagAbort$).

A \emph{history} is a sequence of invocations and responses of the tranasctional operations by one or more processes.
As illustrated below, a history is commonly represented with parallel timelines, where each timeline represents the lifetime of a transaction.
\input{figures/sample}
A history induces a real-time order between transactions (denoted $\hb_h$).
This order holds between two transactions $T_i$ and $T_j$ when $T_i$ terminates in $h$ before $T_j$ begins.
For instance in history $h_2$, transaction $T_2=w(x)$ precedes transaction $T_3=r(x)$.
When two transactions are noto related with real-time, they are \emph{concurrent}.

A \emph{version} is the state of a register as produced by the write of a transaction.
When transaction $T_i$ writes to some register $x$, an operation denoted $w_i(x_i)$, it creates a new version $x_i$ of $x$.
Versions allow to uniquely identify the state of a register as observed by a read operation, e.g., $r_3(x_1)$ in $h_2$.
When a transaction $T_i$ reads version $x_j$, we shall say that $T_i$ \emph{read-from} transaction $T_1$.

Given some history $h$ and some register $x$, a version order on $x$ for $h$ is a total order relation over the versions of $x$ in $h$.
By extension, a version order for $h$, is the union of all the version orders for all registers (denoted $\ll_h$)
For instance, in history $h_1$ above,  we may consider the version order $(x_1 \ll_{h_1} x_2)$.

A transaction $T_i$ \emph{depends on} a transaction $T_j$, written $T_i \depends T_k$ when $T_i$ reads a version written by $T_j$, or such a relation holds transitively.
A transaction observes a \emph{consistent snapshot} \cite{Chan:1985} when it never misses the effects of some transaction it depends on.
In other words, transaction $T_i$ in a history $h$ observes a consistent snapshot when
\begin{inparaenum}
\item $T_i$ reads version $x_j$,
\item $T_k$ writes version $x_k$, and 
\item $T_i$ depends on $T_{k}$,
\end{inparaenum}
then version $x_k$ is followed by version $x_j$.
Formally, $((r_i(x_j) \in h) \land (w_k(x_k) \in h) \land (T_i \depends T_k)) \implies (x_k \ll_{h,x} x_j)$, where $\ll_{h}$ is some version order defined for history $h$.

\subsection{Contention and bindings}
\labsection{criteria:bindings}

Contention occurs when the steps taken by two transactions interleave, that is if when the two transactions are concurrent.
When the TM is disjoint-access parallel, transactions that do not access the same base objects (i.e., the internals of the TM).
As a conseuqnece, in such a case contention is harmless.

On the other hand, if the two transactions contend on the same object, then they may slow down each other.
With invisible reads, read contention is free as no base objects is written.
Conversely, if the two transactions are writing then it is possible to detect the contention and abort preventively.
In the case where a read-write conflict occurs, a race occurs between the reading and the writing transaction.
In a TM where read are optimistic the arbitrage is simply that the read operations take either place all before the writes, or after.
In the later case, the transaction is bound to read the version produced by the writting transaction.

\begin{definition}[Binding]
  When a transaction $T_i$ reads-from a concurrent transaction $T_j$, we say that $T_i$ is bound to $T_j$ on $x$.
\end{definition}

When a transaction $T_i$ is bound to another transaction $T_j$, to preserve the consistency of its snapshot, $T_i$ must read the updates of $T_j$ as well as its causal dependencies that are intersecting with its read set.
Tracking this causality is difficult for the conention manager since it requires to inspect the readset, or to rely on a global clock.
We observe that it is simpler if the items read previously by $T_i$ are either read also by $T_j$ or by some dependency of $T_j$.
In which case, we will say that the binding is fair.

\begin{definition}[Fair binding]
  Consider that a transaction $T_i$ is bound to transaction $T_j$ on a register $x$.
  We say that this binding is \emph{fair} when, for every register $y$ read before $x$, either $y$ is read by $T_j$ or by some dependency of $T_j$.
\end{definition}

As an example, consider history $h_1$.
In this history, ...

\subsection{Stricter serializability}
\labsection{criteria:spser}

Stricter serializability (S+SER) is a stronger consistency criteria than strict serializability (SSER).
As SSER, this criteria requires that committed transactions form a sequential history.
In addiition, S+SER prohibits transactions to view inconsistencies unless one of their bindings is unfair.
Below, we give a graph characterization of stricter serializability.

\begin{definition}[Serialization graph]
  Consider some version order $\ll_h$ for $h$.
  We note $<$ the relations over the commmitted transactions in $h$ induced by $\ll_h$; namely:
  \begin{displaymath}
    \begin{array}{l}
      T_i < T_{j \neq i}  \equaldef \\
      \lor~ T_i \hb_h T_j {\hspace{16.8em}\text{(1)}} \\
      \lor~ \exists x : \lor~ r_j(x_i) \in h {\hspace{13.3em}\text{(2)}} \\
      \hspace{2.9em}\lor~ \exists T_k : x_k \ll_{h,x} x_j \land \lor~T_k = T_i {\hspace{5em}\text{(3)}} \\
      \hspace{12.2em} \lor~ r_i(x_k) \in h {\hspace{3.9em}\text{(4)}}
    \end{array}
  \end{displaymath}
\end{definition}

In the above definition, (1) is a real-time order between $T$ and $T'$, (2) a read-write dependency, (3) a version ordering, and (4) an anti-dependency.

\begin{definition}[Stricter serializability]
  A history $h$ belongs to stricter serializability if its serialization graph is acyclic and if some transaction $T_i$ observes an inconsistent snapshot in $h$, then oene of its bindings is unfair.
\end{definition}

