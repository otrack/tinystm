\section{Introduction}
\labsection{introduction}

% why TM
The advent of chip level multiprocessing in commodity hardware has pushed applications to be more and more parallel in order to leverage the increase of computational power.
However, the art of concurrent programming is known to be a difficult task~\cite{Lee:2006:PT:1137232.1137289}, and new paradigms are required to help the programmer.
Software Transactional Memory (TM) is widely considered as a promising paradigm in this direction, in particular thanks to its simplicity and programmer's friendliness~\cite{Dragojevic:2011:WSM:1924421.1924440}.

% the case for invisible optimistic reads and DAP
The engine that orchestrates concurrent transactions run by the application, i.e., the concurrency manager, is one of the core aspects of a STM implementation.
A large number of concurrency manager implementations exists, ranging from pessimistic lock-based implementations~\cite{harris2005revocable,afek2012pessimistic} to completely optimistic ones~\cite{hassan2014optimistic}, with~\cite{perelman2011smv} or without multi-version support~\cite{attiya2012single}.
Because application workloads exhibit in general a high degree of parallelism\vs{is this a known fact? for which applications? a ref that assess this statement would be good imho}, these designs tend to favor optimistic concurrency control.
In particular, a widely accepted approach consists in executing tentatively invisible read operations and validating them on the course of the transaction execution to enforce consistency.
Another property of interest is disjoint-access parallelism (DAP) \cite{}.
DAP ensures that concurrent transactions operating on disjoint part of the application do not contend in the concurrency manager.
This property is key to ensures that the system scales with the numbers of cores.

% why OPA
From a developper point of view, the interleaving of transactions must satisfy some form of correctness.
Strict serializability (SSER) is a consistency criteria commonly encountered in database litterature.
This criteria ensures committed transactions behave as if they were executed sequentially, in an order compatible with real-time.
Unfortunately, SSER does not say anything about transaction that abort.
To illustrate this point, let us consider history $h_1$ where transaction $T_1=r(x);r(y)$ and $T_2=w(x);w(y)$ execute concurrently.
In this history $T_1$ aborts after reading inconsistent values for $x$ and $y$, yet this history $h_1$ is allowed by SSER 
\input{figures/not-opaque}
Opacity (OPA) was introduced to avoid the side-effects of so-called doom transactions, i.e., transactions which eventually abort (such as $T_1$ in history $h_1$).%
\footnote{  
  Allowing $T_1$ to return both $x_0$ and $y_2$ may have dire consequences in a non-managed environement.
  % def. notion of managed env., that is an environment Ã  la PL/SQL where object are sronngly typed and exception caught.
  For instance \cite{opa}, transaction $T_1$ may compute a division by $0$, leading the program to crash.
}
In addition to SSER, OPA requires that aborted transactions observe a prefix of the committed transactions.
This is the usual consistency criteria for TM.

% the cost of achieving OPA
Achieving OPA is known to be expensive, even for weak progess properties on the transactions \cite{}.
In particular, ensuring that a transaction always observes a consistent snapshot when read are invisible require to either validate the read set after each read operation, or to rely on a global clock.
The former approach results in a quadratic-time validation complexity.
The latter approach is expensive in multi-core/multi-processors architecture, due to a synchronization wall.

% our contributions
In this paper, we address these shortcomings with a new consistency criteria, named stricter serializability (S+SER).
This criteria extends strict serializability while avoiding the inconsistency depicted in history $h_1$.
We present a matching TM algorithm that ensures DAP, invisible reads, and permits transactions to commit as long as they do do contend with conflicting transactions.
We then validate our design by means of a full implementation and several experiments.
Our result shows that when the workloads is strongly parallelism, our algorithm offers performance close to the optimum.

\textbf{Outline.}
The outline of this paper is as follows.
\refsection{criteria} introduces S+SER.
The algorithm and a formal proof of its correctnesss are presented in ~\refsection{stm}
\refsection{evaluation} presents our extensive evaluation against several benchmarks.
We survey related work in \refsection{relatedwork}.
\refsection{conclusion} closes this paper.
